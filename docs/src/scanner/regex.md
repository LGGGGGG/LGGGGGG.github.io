# 词法分析器涉及到的技术

编译器中的词法分析器，其功能是读入源代码，输出源代码中每个 token 所属的类别。

如果觉得太抽象了，请阅读下面的段子。

让我们考虑下面一个任务，给定一个字符串(qwerty123456)，仅由数字和字母组成，从左到右扫描这个字符串，在遇到数字时输出"digit"，遇到字母时输出"character"。

各位聪明的同学肯定微微一笑，随手就敲出如下代码：

```cpp
    string s = "qwerty123456";
    for(const auto&c : s)
    {
        if(c >= '0' && c <= '9') cout << "digit";
        else cout << "character";
    }

```

现在让我们把这个任务升级，给定一个字符串(qwe123rty456)，仅由数字和字母组成，连续的数字称作“数”，连续的字母称作“单词”，从左到右扫描这个字符串，在遇到“数”时输出"number"，遇到时输出"word"。

各位聪明的同学咧嘴一笑：“就这？”，随手就敲出如下代码：

```cpp
    string s = "qwe123rty456";
    int n = s.size();
    for(int i = 0;i < n;++i)
    {
        if(s[i] >= '0' && s[i] <= '9')
        {
            while(i < n && s[i] >= '0' && s[i] <= '9') ++i;
            cout << "number";
            --i;
        }
        else
        {
            while(i < n && (s[i] >= 'a' && s[i] <= 'z') || (s[i] >= 'A' s[i] <= 'Z')) ++i;
            cout << "word";
            --i;
        }
    }
```

我们的任务继续升级，给定一个长文本，由 ASCII 字符组成，该文本长不超过 1e6 个字符，扫描这个文本，给定一个模式串数组，模式串数组长不超过 50，每个模式串长不超过 1e6 个字符，扫描该长文本，如果子串与模式串数组中的某个模式串匹配就输出该模式串，长文本保证是模式串的组合。

看到这里，算法学得不好的同学出汗了，$O(mn)$的暴力算法显然超时，上课记得说过一个叫什么 K 啥啥的算法应该可以解。算法学得认真的同学会回答，这可以用 KMP 来做，单个模式串匹配复杂度$O(m+n)$,总复杂度$O(l(m + n))$刚好卡在边上。算法大神则不屑一顾，KMP 本质上是一种**有限状态自动机**，这题是标准的 AC 自动机模板题，用 trie 优化能降低每次询问的复杂度。助教拍手称赞，提出问题，联系词法分析器要完成的功能，最后一问和词法分析器是否有一些联系呢？

机灵的同学已经发现了，最后一个问题实际上就是一个词法分析器的抽象，刚上完计算理论的同学已经明了了，哦，构建一个编程语言词法分析器原来就是构建一个有限状态自动机啊，字符集就是编程语言允许的字符，用接受状态集合来代表编程语言允许的关键词、变量、表达式。懂了，马上动手实现。

而没有上过的同学则云里雾里，啥啥啥，说得都是啥。没关系，本文会从头开始给没学过的同学灌输必要的知识，大家先要有的大体认知是：为了更快地扫描源程序，我们要实现一个有限状态自动机，这个有限状态自动机就是词法分析器。

我们这里不会做更细致的讲解，同学们只需要死记硬背：确定性有限状态自动机(DFA)与非确定性有限状态自动机（NFA）与正则表达式（regular expression）等价。我们要实现的 DFA，正则表达式是更数学更易于书写的表达，NFA 是相较于 DFA 更容易编程实现的表达。有了如上两个性质，所以接下来，我们依照大多数编译教材都采用的顺序，先学习正则表达式了解表示覆盖所需字符串的理论，再学习 DFA 了解状态少的 DFA 具体怎么实现，最后学习如果状态太多，手工构造 DFA 太复杂，我们怎么通过构造不需要推理的 NFA 再转换成 DFA 以构造一个复杂的 DFA 并最小化。

## 正则表达式

现代数学基本从集合开始构造，自动机理论是数学的一个分支，当然也得先从集合讲起。
编译器中的词法分析器，其功能是读入源代码$T$，输出源代码中每个 token 所属的类别。也即：

$$
    f:token \mapsto type \qquad S = \{s|s是符合该编程语言的token\}
$$

$$
    f(token) = \left\{
    \begin{aligned}
        type_x \quad token \in S \\
        error \quad token \notin S
    \end{aligned}
    \right.
$$

我们现在尚不明确的是，如何形式化地表达$S$使得人类和计算机都能理解。我们现在已知的信息是，$S$是元素为字符串的集合。问题明晰为我们应当如何表示一个字符串集合，最简单的当然是列举法，比如，我们要表示整数字符串集合就可以表示为$\{1,2,3...\}$，其中的数字代表的是字符串而不是整数。但现在我们遇到了一些问题，一个编程语言不止含有整数，我们需要的肯定不止一种集合，我们应当怎么表示这些集合的联合？有些集合是无限的，我们应当怎么表示？字符串是否能像数一样进行运算，这些运算能否推到集合上？为了解决这些问题，数学家和语言学家们就发明了正则表达式来解决这些问题。

由于列举法表示一个集合太麻烦了，正则表达式用一个助记符或者说模式(pattern)或者说代表元来代表一个集合，通常写成$L(\bullet) = \{...\}$，其中$\bullet$就是我们说的正则表达式，外面加上$L()$才表示它是一个集合。比如我们考虑单字符集合$\{a\}$，它在这表示文本中的所有字符$a$都属于该集合，或者说能被匹配到该集合。然后我们用正则表达式$\mathbf{a}$(我们特意用加粗的$a$来书写正则表达式)来**代表**这个集合，而$L(\mathbf{a})$就是单字符集合$\{a\}$，即$L(\mathbf{a}) = \{a\}$。在接下来的文章中，我们将会给出正则表达式更正式的定义。

**定义** 正则表达式是以下的一种：

1. 基本正则表达式由一个单字符$\mathbf{a}$（其中$a$在字母表中，这里的字母表在编译原理中一般指 ASCII 字符表或 Unicode 字符表）或者元字符$\mathbf{\epsilon}$（代表空串）或元字符$\mathbf{\phi}$（代表空集）组成。其中$L(\mathbf{a}) = \{a\}$；$L(\mathbf{\epsilon}) = \{\epsilon\}$；$L(\mathbf{\phi}) = \{\}$。注意：空串不等于空集（"" != NULL）。

2. 定义正则表达式的联合或者说选择运算 $|$（具有类似实数加法的性质），该运算产生新的正则表达式。例如，对于正则表达式$\mathbf{a}|\mathbf{b}$，其对应的集合运算为：$L(\mathbf{a}|\mathbf{b}) = L(\mathbf{a}) \cup L(\mathbf{b}) = \{a\} \cup \{b\} = \{a, b\}$
3. 定义正则表达式的连结运算 $\cdot$（类似实数乘法因此一般可以省略不写），该运算产生新的正则表达式。例如，对于正则表达式$\mathbf{a}\mathbf{b}$,其对应的集合运算为$L(\mathbf{a}\mathbf{b}) = L(\mathbf{a})L(\mathbf{b}) = \{a\} \cdot \{b\}=\{ab\}$。对于字符集合来说 $\cdot$ 运算的规律是："$\cdot$ "右边的集合中的所有元素要附在左边集合的所有元素后面，这意味着该运算是不交换的。例如：$S_1 = \{aa, b\} \qquad S_2 = \{a, bb\} \qquad S_1 \cdot S_2 = \{aaa, aabb, ba, bbb\}$ 而 $\qquad S_2 \cdot S_1 = \{aaa, ab, bbaa, bbb\}$。
4. 定义正则表达式的重复运算 $*$，该运算产生新的正则表达式。例如，对于正则表达式$\mathbf{a^*}$，其对应的集合运算为：定义$\mathbf{a^i}$代表$i$次连结运算，$i=0$时代表空串，则$L(\mathbf{a^*}) =L(\sum_{i = 0}^{\infty}\mathbf{a^i})=\{\epsilon\}\cup\{a\}\cup\{aa\}\cup\{aaa\}\cup...=\{\epsilon,a,aa,aaa,...\}$。

上述四种运算的组合可生成所有的正则表达式。正则表达式按同优先级高低从左到右运算，为了指定顺序，正则表达式还引入了扩号运算符$(·)$，规定括号内的正则表达式优先运算。各运算符优先级如下：$() > * > · > |$。例如：正则表达式$c(a|b)^*$先运算括号内的$a|b$，再进行$(·)^*$运算，最后才是$c·$运算。

到这里，正则表达式作为一种**描述集合的语言**就被我们介绍完了，同时也要注意的事是正则表达式并不能描述所有的集合，具体哪些集合这是计算理论课上的东西，本门课只需要知道的是：**正则表达式不能计数**,比如这个集合 $\left \{ 0^n1^n|n是正整数 \right\}$就无法被正则表达式描述。

下面介绍一些在实践中产生的正则表达式的记号，但是未必所有的正则表达式实现方都接受这些符号:

$+$ 代表至少重复一次，例如$\mathbf{a+}=\mathbf{aa^*}$

https://regexone.com/

https://alf.nu/RegexGolf?world=regex&level=r00
